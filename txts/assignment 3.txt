#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

// Structure for an MNT entry
struct MacroDefinition {
    string name;
    int mdt_start_index;
    int parameter_count = 0;
    map<string, int> pntab; // Parameter Name Table
    map<string, string> default_params;
};

// --- Global Data Structures ---
map<string, MacroDefinition> MNT;
vector<string> MDT;

vector<string> split(const string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

void writeTablesToFile() {
    ofstream mnt_out("mnt.txt");
    mnt_out << "#Name\t#Params\tMDT_Index\n";
    for (const auto& pair : MNT) {
        mnt_out << pair.first << "\t" << pair.second.parameter_count << "\t" << pair.second.mdt_start_index << "\n";
    }
    mnt_out.close();

    ofstream mdt_out("mdt.txt");
    mdt_out << "#Index\tDefinition\n";
    for (size_t i = 0; i < MDT.size(); ++i) {
        mdt_out << i << "\t" << MDT[i] << "\n";
    }
    mdt_out.close();
}

int main() {
    ifstream inputFile("input.txt");
    ofstream outputFile("expanded_code.txt");

    if (!inputFile.is_open()) {
        cerr << "Error: Could not open input.txt" << endl;
        return 1;
    }

    string line;
    bool isDefiningMacro = false;
    MacroDefinition currentMacro;

    while (getline(inputFile, line)) {
        stringstream ss(line);
        vector<string> tokens;
        string token;
        while (ss >> token) tokens.push_back(token);
        if (tokens.empty()) continue;

        // --- 1. Handle Macro Definition ---
        if (tokens[0] == "MACRO") {
            isDefiningMacro = true;
            getline(inputFile, line); // Get prototype line
            stringstream proto_ss(line);
            vector<string> proto_tokens;
            while(proto_ss >> token) proto_tokens.push_back(token);

            currentMacro = MacroDefinition();
            currentMacro.name = proto_tokens[0];
            currentMacro.mdt_start_index = MDT.size();
            MDT.push_back(line); // Store raw prototype

            // Process parameters
            for (size_t i = 1; i < proto_tokens.size(); ++i) {
                currentMacro.parameter_count++;
                string param = proto_tokens[i];
                if (param.back() == ',') param.pop_back();

                size_t equals_pos = param.find('=');
                string param_name = param;
                if (equals_pos != string::npos) { // Has default value
                    param_name = param.substr(0, equals_pos);
                    string default_val = param.substr(equals_pos + 1);
                    currentMacro.default_params[param_name] = default_val;
                }
                currentMacro.pntab[param_name] = currentMacro.parameter_count;
            }
            continue;
        }

        if (tokens[0] == "MEND") {
            isDefiningMacro = false;
            MDT.push_back(line); // Store MEND
            MNT[currentMacro.name] = currentMacro; // Save to MNT
            continue;
        }

        if (isDefiningMacro) {
            // Replace formal params with positional placeholders (e.g., &O -> ?1)
            string processed_line = tokens[0]; // Opcode
            for (size_t i = 1; i < tokens.size(); ++i) {
                string arg = tokens[i];
                if (arg.back() == ',') arg.pop_back();

                if (currentMacro.pntab.count(arg)) {
                    processed_line += " ?" + to_string(currentMacro.pntab[arg]);
                } else {
                    processed_line += " " + arg;
                }
                if (tokens[i].back() == ',') processed_line += ",";
            }
            MDT.push_back(processed_line); // Store processed line
            continue;
        }
        outputFile << line << endl;
    }

    inputFile.close();
    outputFile.close();

    writeTablesToFile();
    cout << "\n Pass-I of macro-processor complete." << endl;
    cout << "   - Intermediate code (with macro calls) written to expanded_code.txt" << endl;
    cout << "   - Macro Name Table written to mnt.txt" << endl;
    cout << "   - Macro Definition Table written to mdt.txt" << endl;

    return 0;
}
