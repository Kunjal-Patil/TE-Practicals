#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

// A structure to hold all information about a defined macro.
// This represents an entry in the Macro Name Table (MNT).
struct MacroDefinition {
    string name;
    int mdt_start_index;
    int parameter_count = 0;
    // PNTAB: Maps parameter name (e.g., "&O") to its positional index (e.g., 1)
    map<string, int> pntab;
    // Stores default values for parameters
    map<string, string> default_params;
};

// --- Global Data Structures ---
// Macro Name Table (MNT): Maps a macro's name to its full definition details.
map<string, MacroDefinition> MNT;
// Macro Definition Table (MDT): Stores the body of all macros sequentially.
vector<string> MDT;

// Helper function to split a string by a delimiter, used for parsing arguments.
vector<string> split(const string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

// Function to write the final MNT and MDT to their respective files.
void writeTablesToFile() {
    ofstream mnt_out("mnt.txt");
    mnt_out << "#Name\t#Params\tMDT_Index\n";
    for (const auto& pair : MNT) {
        mnt_out << pair.first << "\t" << pair.second.parameter_count << "\t" << pair.second.mdt_start_index << "\n";
    }
    mnt_out.close();

    ofstream mdt_out("mdt.txt");
    mdt_out << "#Index\tDefinition\n";
    for (size_t i = 0; i < MDT.size(); ++i) {
        mdt_out << i << "\t" << MDT[i] << "\n";
    }
    mdt_out.close();
}

int main() {
    ifstream inputFile("input.txt");
    ofstream outputFile("expanded_code.txt");

    if (!inputFile.is_open()) {
        cerr << "Error: Could not open input.txt" << endl;
        return 1;
    }

    string line;
    bool isDefiningMacro = false;
    MacroDefinition currentMacro;

    // Main loop to process the input file line by line
    while (getline(inputFile, line)) {
        stringstream ss(line);
        vector<string> tokens;
        string token;
        while (ss >> token) tokens.push_back(token);
        if (tokens.empty()) continue;

        // --- 1. Handle Macro Definition ---
        if (tokens[0] == "MACRO") {
            isDefiningMacro = true;
            // The next line is the macro prototype
            getline(inputFile, line);
            stringstream proto_ss(line);
            vector<string> proto_tokens;
            while(proto_ss >> token) proto_tokens.push_back(token);

            // Initialize a new MacroDefinition object
            currentMacro = MacroDefinition();
            currentMacro.name = proto_tokens[0];
            currentMacro.mdt_start_index = MDT.size();
            MDT.push_back(line); // Store the raw prototype in the MDT

            // Process parameters from the prototype
            for (size_t i = 1; i < proto_tokens.size(); ++i) {
                currentMacro.parameter_count++;
                string param = proto_tokens[i];
                if (param.back() == ',') param.pop_back();

                size_t equals_pos = param.find('=');
                string param_name = param;
                if (equals_pos != string::npos) { // Parameter has a default value
                    param_name = param.substr(0, equals_pos);
                    string default_val = param.substr(equals_pos + 1);
                    currentMacro.default_params[param_name] = default_val;
                }
                currentMacro.pntab[param_name] = currentMacro.parameter_count;
            }
            continue;
        }

        if (tokens[0] == "MEND") {
            isDefiningMacro = false;
            MDT.push_back(line); // Store the MEND line
            MNT[currentMacro.name] = currentMacro; // Save the completed macro to the MNT
            continue;
        }

        if (isDefiningMacro) {
            // Replace formal parameters with positional placeholders (e.g., &O -> ?1)
            string processed_line = tokens[0]; // The opcode
            for (size_t i = 1; i < tokens.size(); ++i) {
                string arg = tokens[i];
                if (arg.back() == ',') arg.pop_back();

                if (currentMacro.pntab.count(arg)) {
                    processed_line += " ?" + to_string(currentMacro.pntab[arg]);
                } else {
                    processed_line += " " + arg;
                }
                if (tokens[i].back() == ',') processed_line += ",";
            }
            MDT.push_back(processed_line); // Store processed line in MDT
            continue;
        }

        // --- 2. Handle Macro Expansion ---
        if (MNT.count(tokens[0])) {
            cout << "Expanding macro call: " << line << endl;
            MacroDefinition& macro = MNT[tokens[0]];

            // Build Argument List Array (ALA) mapping position to actual argument
            map<int, string> ala;
            if (tokens.size() > 1) {
                vector<string> actual_params = split(tokens[1], ',');
                for(size_t i = 0; i < actual_params.size(); ++i) {
                    ala[i + 1] = actual_params[i];
                }
            }

            // Fill in default parameters if they were not provided in the call
            for(const auto& pair : macro.pntab) {
                if (ala.find(pair.second) == ala.end()) { // If parameter is missing
                    ala[pair.second] = macro.default_params[pair.first];
                }
            }

            // Expand the macro body using the ALA
            for (int i = macro.mdt_start_index + 1; ; ++i) {
                string mdt_line = MDT[i];
                if (mdt_line == "MEND") break;

                stringstream mdt_ss(mdt_line);
                vector<string> mdt_tokens;
                string mdt_token;
                while(mdt_ss >> mdt_token) mdt_tokens.push_back(mdt_token);

                string expanded_line = mdt_tokens[0]; // Start with opcode
                for (size_t j = 1; j < mdt_tokens.size(); ++j) {
                    string arg_token = mdt_tokens[j];
                    bool has_comma = false;
                    if (arg_token.back() == ',') {
                        has_comma = true;
                        arg_token.pop_back();
                    }

                    if (arg_token[0] == '?') { // It's a parameter placeholder
                        int param_index = stoi(arg_token.substr(1));
                        expanded_line += " " + ala[param_index];
                    } else {
                        expanded_line += " " + arg_token;
                    }
                     if (has_comma) expanded_line += ",";
                }
                outputFile << expanded_line << endl;
            }
            continue;
        }

        // --- 3. Handle Regular Assembly Lines ---
        outputFile << line << endl;
    }

    inputFile.close();
    outputFile.close();

    // Write the final MNT and MDT data structures to files
    writeTablesToFile();
    cout << "\n Pass-I of macro-processor complete." << endl;
    cout << "   - Expanded code written to expanded_code.txt" << endl;
    cout << "   - Macro Name Table written to mnt.txt" << endl;
    cout << "   - Macro Definition Table written to mdt.txt" << endl;

    return 0;
}