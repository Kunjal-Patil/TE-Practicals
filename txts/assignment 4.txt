#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <map>

using namespace std;

// Structure to hold macro definition details (an MNT entry)
struct MacroDefinition {
    string name;
    int mdt_start_index;
    int parameter_count = 0;
    map<string, int> pntab;
    map<string, string> default_params;
};

// --- Global Data Structures ---
map<string, MacroDefinition> MNT;
vector<string> MDT;
ofstream finalOutputFile; // Global so recursive calls can write to it

// Helper to split strings by a delimiter
vector<string> split(const string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

// Function to load the MNT and MDT from files created by Pass-I
void loadTables() {
    ifstream mnt_in("mnt.txt");
    string line;
    getline(mnt_in, line); // Skip header
    while (getline(mnt_in, line)) {
        stringstream ss(line);
        string name;
        int param_count, mdt_index;
        ss >> name >> param_count >> mdt_index;
        MNT[name] = {name, mdt_index, param_count}; // Basic info for now
    }
    mnt_in.close();

    ifstream mdt_in("mdt.txt");
    getline(mdt_in, line); // Skip header
    while (getline(mdt_in, line)) {
        // The line in MDT is stored as "index\tdefinition"
        MDT.push_back(line.substr(line.find('\t') + 1));
    }
    mdt_in.close();

    // Now, populate PNTAB and defaults in MNT by parsing the prototype from MDT
    for (auto& mnt_pair : MNT) {
        MacroDefinition& macro = mnt_pair.second;
        string prototype = MDT[macro.mdt_start_index];
        stringstream proto_ss(prototype);
        vector<string> proto_tokens;
        string token;
        while(proto_ss >> token) proto_tokens.push_back(token);

        for (size_t i = 1; i < proto_tokens.size(); ++i) {
            string param = proto_tokens[i];
            if (param.back() == ',') param.pop_back();

            size_t equals_pos = param.find('=');
            string param_name = param;
            if (equals_pos != string::npos) {
                param_name = param.substr(0, equals_pos);
                string default_val = param.substr(equals_pos + 1);
                macro.default_params[param_name] = default_val;
            }
            macro.pntab[param_name] = i; // Positional index is simply its order
        }
    }
}

// The core recursive expansion function
void expandMacro(const string& macro_call_line) {
    stringstream ss(macro_call_line);
    vector<string> tokens;
    string token;
    while(ss >> token) tokens.push_back(token);

    string macro_name = tokens[0];
    MacroDefinition& macro = MNT[macro_name];
    cout << "  Expanding nested call: " << macro_name << endl;

    // 1. Build ALA for this expansion
    map<int, string> ala;
     if (tokens.size() > 1) {
        // Arguments can be complex (e.g., O,9,&E=CREG), so don't split by comma blindly
        string all_args = macro_call_line.substr(macro_call_line.find(tokens[1]));
        vector<string> actual_params = split(all_args, ',');
        for(size_t i = 0; i < actual_params.size(); ++i) {
            ala[i + 1] = actual_params[i];
        }
    }

    // 2. Fill in defaults
    for (const auto& pair : macro.pntab) {
        if (ala.find(pair.second) == ala.end()) {
            ala[pair.second] = macro.default_params[pair.first];
        }
    }

    // 3. Process MDT lines
    for (int i = macro.mdt_start_index + 1; ; ++i) {
        string mdt_line = MDT[i];
        if (mdt_line.find("MEND") != string::npos) break;

        // Substitute parameters
        stringstream mdt_ss(mdt_line);
        vector<string> mdt_tokens;
        string mdt_token;
        while(mdt_ss >> mdt_token) mdt_tokens.push_back(mdt_token);
        
        string expanded_line = mdt_tokens[0];
        for (size_t j = 1; j < mdt_tokens.size(); ++j) {
            string arg_token = mdt_tokens[j];
            bool has_comma = false;
            if (arg_token.back() == ',') {
                has_comma = true;
                arg_token.pop_back();
            }

            if (arg_token[0] == '?') { // Is a positional parameter
                int param_index = stoi(arg_token.substr(1));
                expanded_line += " " + ala[param_index];
            } else {
                expanded_line += " " + arg_token;
            }
            if (has_comma) expanded_line += ",";
        }

        // 4. Check for further nesting
        stringstream expanded_ss(expanded_line);
        string first_word;
        expanded_ss >> first_word;
        if (MNT.count(first_word)) {
            expandMacro(expanded_line); // Recursive call
        } else {
            finalOutputFile << expanded_line << endl;
        }
    }
}

int main() {
    cout << "--- Starting Macro Processor Pass-II ---" << endl;
    loadTables();
    cout << "MNT and MDT loaded successfully." << endl;

    ifstream inputFile("expanded_code.txt");
    finalOutputFile.open("final_expanded_code.txt");

    if (!inputFile.is_open()) {
        cerr << "Error: Could not open expanded_pass_one.txt" << endl;
        return 1;
    }

    string line;
    while (getline(inputFile, line)) {
        stringstream ss(line);
        string first_word;
        ss >> first_word;

        if (MNT.count(first_word)) {
            cout << "Found macro call in intermediate file: " << line << endl;
            expandMacro(line);
        } else {
            // It's a regular assembly line, write it directly
            finalOutputFile << line << endl;
        }
    }

    inputFile.close();
    finalOutputFile.close();

    cout << "\nâœ… Pass-II of macro-processor complete." << endl;
    cout << "   - Final expanded code written to final_expanded_code.txt" << endl;

    return 0;
}