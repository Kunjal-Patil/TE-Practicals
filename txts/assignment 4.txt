#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <map>

using namespace std;

struct MacroDefinition {
    string name;
    int mdt_start_index;
    int parameter_count = 0;
    map<string, int> pntab;
    map<string, string> default_params;
};

map<string, MacroDefinition> MNT;
vector<string> MDT;

vector<string> split(const string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

void loadTables() {
    ifstream mnt_in("mnt.txt");
    string line;
    getline(mnt_in, line); // Skip header
    while (getline(mnt_in, line)) {
        stringstream ss(line);
        string name;
        int param_count, mdt_index;
        ss >> name >> param_count >> mdt_index;
        MNT[name] = {name, mdt_index, param_count};
    }
    mnt_in.close();

    ifstream mdt_in("mdt.txt");
    getline(mdt_in, line); // Skip header
    while (getline(mdt_in, line)) {
        MDT.push_back(line.substr(line.find('\t') + 1));
    }
    mdt_in.close();

    for (auto& mnt_pair : MNT) {
        MacroDefinition& macro = mnt_pair.second;
        string prototype = MDT[macro.mdt_start_index];
        stringstream proto_ss(prototype);
        vector<string> proto_tokens;
        string token;
        while(proto_ss >> token) proto_tokens.push_back(token);

        for (size_t i = 1; i < proto_tokens.size(); ++i) {
            string param = proto_tokens[i];
            if (param.back() == ',') param.pop_back();

            size_t equals_pos = param.find('=');
            string param_name = param;
            if (equals_pos != string::npos) {
                param_name = param.substr(0, equals_pos);
                string default_val = param.substr(equals_pos + 1);
                macro.default_params[param_name] = default_val;
            }
            macro.pntab[param_name] = i;
        }
    }
}

void expandMacroAndWrite(const string& macro_call_line, ofstream& finalOutputFile) {
    stringstream ss(macro_call_line);
    vector<string> tokens;
    string token;
    while(ss >> token) tokens.push_back(token);

    string macro_name = tokens[0];
    MacroDefinition& macro = MNT[macro_name];
    cout << "  Expanding call: " << macro_name << endl;

    map<int, string> ala;
     if (tokens.size() > 1) {
        string all_args;
        size_t first_arg_pos = macro_call_line.find(tokens[1]);
        if (first_arg_pos != string::npos) {
            all_args = macro_call_line.substr(first_arg_pos);
        }
        
        vector<string> actual_params = split(all_args, ',');
        for(size_t i = 0; i < actual_params.size(); ++i) {
            ala[i + 1] = actual_params[i];
        }
    }

    for (const auto& pair : macro.pntab) {
        if (ala.find(pair.second) == ala.end()) {
            if (macro.default_params.count(pair.first)) {
                ala[pair.second] = macro.default_params[pair.first];
            }
        }
    }

    for (int i = macro.mdt_start_index + 1; ; ++i) {
        string mdt_line = MDT[i];
        if (mdt_line.find("MEND") != string::npos) break;

        stringstream mdt_ss(mdt_line);
        vector<string> mdt_tokens;
        string mdt_token;
        while(mdt_ss >> mdt_token) mdt_tokens.push_back(mdt_token);
        
        string expanded_line = mdt_tokens[0];
        for (size_t j = 1; j < mdt_tokens.size(); ++j) {
            string arg_token = mdt_tokens[j];
            bool has_comma = false;
            if (arg_token.back() == ',') {
                has_comma = true;
                arg_token.pop_back();
            }

            if (arg_token[0] == '?') {
                int param_index = stoi(arg_token.substr(1));
                expanded_line += " " + ala[param_index];
            } else {
                expanded_line += " " + arg_token;
            }
            if (has_comma) expanded_line += ",";
        }

        finalOutputFile << expanded_line << endl;
    }
}

int main() {
    cout << "--- Starting Macro Processor Pass-II ---" << endl;
    loadTables();
    cout << "MNT and MDT loaded successfully." << endl;

    ifstream inputFile("expanded_code.txt");
    ofstream finalOutputFile("final_expanded_code.txt");

    if (!inputFile.is_open()) {
        cerr << "Error: Could not open expanded_code.txt" << endl;
        return 1;
    }

    string line;
    while (getline(inputFile, line)) {
        stringstream ss(line);
        string first_word;
        ss >> first_word;

        if (MNT.count(first_word)) {
            cout << "Found macro call in intermediate file: " << line << endl;
            expandMacroAndWrite(line, finalOutputFile);
        } else {
            finalOutputFile << line << endl;
        }
    }

    inputFile.close();
    finalOutputFile.close();

    cout << "\n Pass-II of macro-processor complete." << endl;
    cout << "   - Final expanded code written to final_expanded_code.txt" << endl;

    return 0;
}
